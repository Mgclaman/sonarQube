# -*- coding: utf-8 -*-
"""personalized student learning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D4ikvIT881b74Eml2MZ6dNjYMUVpY475
"""

#"I'll create a comprehensive Python program that implements a personalized learning path recommendation system using dynamic knowledge graphs, Personalized PageRank, and min-cost flow algorithms.

"""
Personalized Learning Path Recommendation System
Uses Personalized PageRank and Min-Cost Flow to find optimal prerequisite paths
"""

import numpy as np
from collections import defaultdict, deque
from typing import List, Tuple, Set, Dict, Optional
import heapq
from dataclasses import dataclass
import networkx as nx
from scipy.sparse import csr_matrix
from scipy.sparse.linalg import spsolve
import warnings
warnings.filterwarnings('ignore')


@dataclass
class StudentProgress:
    """"Tracks student's mastery status for concepts"""
    student_id: str
    mastered_concepts: Set[str]
    interaction_history: List[Tuple[str, str, bool]]  # (student_id, concept_id, mastery_status)


class KnowledgeGraph:
    """Directed graph representing concept prerequisites"""

    def __init__(self):
        self.graph = defaultdict(list)  # concept -> list of prerequisites
        self.reverse_graph = defaultdict(list)  # concept -> list of dependents
        self.all_concepts = set()

    def add_prerequisite(self, concept: str, prerequisite: str):
        """Add a prerequisite relationship"""
        self.graph[concept].append(prerequisite)
        self.reverse_graph[prerequisite].append(concept)
        self.all_concepts.add(concept)
        self.all_concepts.add(prerequisite)

    def get_prerequisites(self, concept: str) -> List[str]:
        """Get direct prerequisites of a concept"""
        return self.graph.get(concept, [])

    def get_dependents(self, concept: str) -> List[str]:
        """"Get concepts that depend on this concept"""
        return self.reverse_graph.get(concept, [])

    def get_all_prerequisites(self, concept: str) -> Set[str]:
        """Get all prerequisites (direct and indirect) using BFS"""
        visited = set()
        queue = deque([concept])
        all_prereqs = set()

        while queue:
            current = queue.popleft()
            if current in visited:
                continue
            visited.add(current)

            for prereq in self.get_prerequisites(current):
                all_prereqs.add(prereq)
                queue.append(prereq)

        return all_prereqs


class PersonalizedPageRank:
    """Implements Personalized PageRank for concept relevance ranking"""

    def __init__(self, knowledge_graph: KnowledgeGraph, damping_factor: float = 0.85):
        self.kg = knowledge_graph
        self.damping_factor = damping_factor
        self.concept_to_idx = {c: i for i, c in enumerate(sorted(self.kg.all_concepts))}
        self.idx_to_concept = {i: c for c, i in self.concept_to_idx.items()}
        self.n_concepts = len(self.kg.all_concepts)

    def _build_transition_matrix(self) -> csr_matrix:
        """Build sparse transition matrix for PageRank"""
        rows, cols, data = [], [], []

        for concept in self.kg.all_concepts:
            concept_idx = self.concept_to_idx[concept]
            prerequisites = self.kg.get_prerequisites(concept)

            if prerequisites:
                weight = 1.0 / len(prerequisites)
                for prereq in prerequisites:
                    prereq_idx = self.concept_to_idx[prereq]
                    cols.append(prereq_idx) # Fixed: Added column index
                    rows.append(concept_idx) # Fixed: Added row index
                    data.append(weight)
            else:
                # Self-loop for concepts with no prerequisites
                rows.append(concept_idx)
                cols.append(concept_idx)
                data.append(1.0)

        return csr_matrix((data, (rows, cols)), shape=(self.n_concepts, self.n_concepts))

    def compute_personalized_pagerank(self,
                                    mastered_concepts: Set[str],
                                    target_concept: str,
                                    iterations: int = 50) -> Dict[str, float]:
        """
        Compute Personalized PageRank scores for all concepts

        Args:
            mastered_concepts: Set of concepts the student has mastered
            target_concept: The concept the student wants to learn
            iterations: Number of PageRank iterations

        Returns:
            Dictionary mapping concept to relevance score
        """
        # Build personalization vector
        personalization = np.zeros(self.n_concepts)

        # Give weight to target concept and its prerequisites
        if target_concept in self.concept_to_idx: # Added: Check if target concept is in the graph
          target_idx = self.concept_to_idx[target_concept]
          personalization[target_idx] = 0.5

        # Give weight to mastered concepts (as starting points)
        if mastered_concepts:
            mastered_weight = 0.5 / len(mastered_concepts)
            for concept in mastered_concepts:
                if concept in self.concept_to_idx:
                    personalization[self.concept_to_idx[concept]] = mastered_weight

        # Normalize personalization vector
        if personalization.sum() > 0:
            personalization /= personalization.sum()
        else:
            personalization = np.ones(self.n_concepts) / self.n_concepts

        # Build transition matrix
        transition_matrix = self._build_transition_matrix()

        # Initialize PageRank vector
        pagerank = np.ones(self.n_concepts) / self.n_concepts

        # Power iteration
        for _ in range(iterations):
            pagerank = (self.damping_factor * transition_matrix.dot(pagerank) +
                       (1 - self.damping_factor) * personalization)

        # Convert to dictionary
        scores = {self.idx_to_concept[i]: score
                 for i, score in enumerate(pagerank)}

        return scores


class MinCostFlowSolver:
    """"Solves minimum cost flow to find optimal prerequisite paths"""

    def __init__(self, knowledge_graph: KnowledgeGraph):
        self.kg = knowledge_graph

    def find_minimum_prerequisites(self,
                                 mastered_concepts: Set[str],
                                 target_concept: str,
                                 pagerank_scores: Dict[str, float]) -> Set[str]:
        """""
        Find minimum set of unmastered prerequisites needed to reach target

        Uses a modified min-cost flow approach with cycle handling
        """""
        # Get all prerequisites of target
        all_prereqs = self.kg.get_all_prerequisites(target_concept)

        # Filter out already mastered prerequisites
        unmastered_prereqs = all_prereqs - mastered_concepts

        if not unmastered_prereqs:
            return set()

        # Build subgraph of relevant concepts
        relevant_concepts = unmastered_prereqs | mastered_concepts | {target_concept}

        # Use Dijkstra-like approach to find minimum prerequisite set
        # Cost is based on: 1) number of concepts, 2) PageRank relevance
        min_prereqs = self._dijkstra_prerequisites(
            mastered_concepts,
            target_concept,
            relevant_concepts,
            pagerank_scores,
            unmastered_prereqs # Added: Pass unmastered_prereqs
        )

        return min_prereqs

    def _dijkstra_prerequisites(self,
                               mastered_concepts: Set[str],
                               target_concept: str,
                               relevant_concepts: Set[str],
                               pagerank_scores: Dict[str, float],
                               unmastered_prereqs: Set[str]) -> Set[str]: # Added: Accept unmastered_prereqs
        """
        Modified Dijkstra to find minimum prerequisite set
        """
        # Priority queue: (cost, concept, path_prerequisites)
        pq = []

        # Start from mastered concepts
        for concept in mastered_concepts:
            if concept in relevant_concepts:
                heapq.heappush(pq, (0, concept, set()))

        visited = set()
        best_paths = {}  # concept -> (cost, prerequisites_needed)

        while pq:
            cost, current, prereqs_so_far = heapq.heappop(pq)

            if current in visited:
                continue

            visited.add(current)
            best_paths[current] = (cost, prereqs_so_far)

            # Check if we reached the target
            if current == target_concept:
                return prereqs_so_far

            # Explore dependents
            for dependent in self.kg.get_dependents(current):
                if dependent not in relevant_concepts or dependent in visited:
                    continue

                # Check if all prerequisites of dependent are satisfied
                dep_prereqs = set(self.kg.get_prerequisites(dependent))
                satisfied_prereqs = (dep_prereqs & mastered_concepts) | (dep_prereqs & prereqs_so_far) | {current}

                if dep_prereqs.issubset(satisfied_prereqs):
                    # Can reach this dependent
                    new_prereqs = prereqs_so_far.copy()
                    if current not in mastered_concepts:
                        new_prereqs.add(current)

                    # Calculate cost (lower PageRank score = higher cost)
                    pr_score = pagerank_scores.get(dependent, 0.001)
                    new_cost = cost + (1.0 / pr_score) + len(new_prereqs) * 0.1

                    heapq.heappush(pq, (new_cost, dependent, new_prereqs))

        # If target not reachable, return all unmastered prerequisites
        return unmastered_prereqs


class PersonalizedLearningPathRecommender:
    """"Main class that orchestrates the recommendation system"""

    def __init__(self):
        self.knowledge_graph = KnowledgeGraph()
        self.student_progress = {}  # student_id -> StudentProgress

    def load_interaction_log(self, interactions: List[Tuple[str, str, bool]]):
        """"Load student-concept interaction log"""
        for student_id, concept_id, mastery_status in interactions:
            if student_id not in self.student_progress:
                self.student_progress[student_id] = StudentProgress(
                    student_id=student_id,
                    mastered_concepts=set(),
                    interaction_history=[]
                )

            self.student_progress[student_id].interaction_history.append(
                (student_id, concept_id, mastery_status)
            )

            if mastery_status:
                self.student_progress[student_id].mastered_concepts.add(concept_id)

    def add_prerequisite_relationship(self, concept: str, prerequisite: str):
        """Add a prerequisite relationship to the knowledge graph"""
        self.knowledge_graph.add_prerequisite(concept, prerequisite)

    def recommend_prerequisites(self, student_id: str, target_concept: str) -> Dict:
        """
        Main recommendation function

        Returns:
            Dictionary containing:
            - prerequisites: Set of recommended prerequisite concepts
            - pagerank_scores: Relevance scores for all concepts
            - learning_path: Suggested order of learning
        """
        # Get student's mastered concepts
        if student_id not in self.student_progress:
            mastered_concepts = set()
        else:
            mastered_concepts = self.student_progress[student_id].mastered_concepts

        # Compute Personalized PageRank
        pagerank = PersonalizedPageRank(self.knowledge_graph)
        pagerank_scores = pagerank.compute_personalized_pagerank(
            mastered_concepts, target_concept
        )

        # Find minimum prerequisites using min-cost flow
        flow_solver = MinCostFlowSolver(self.knowledge_graph)
        min_prerequisites = flow_solver.find_minimum_prerequisites(
            mastered_concepts, target_concept, pagerank_scores
        )

        # Generate learning path (order prerequisites by PageRank score)
        learning_path = sorted(
            min_prerequisites,
            key=lambda c: pagerank_scores.get(c, 0),
            reverse=True
        )

        return {
            'prerequisites': min_prerequisites,
            'pagerank_scores': pagerank_scores,
            'learning_path': learning_path,
            'num_prerequisites': len(min_prerequisites)
        }


# Example usage and testing
def main():
    # Initialize the recommender system
    recommender = PersonalizedLearningPathRecommender()

    # Build a sample knowledge graph
    # Math concepts example
    recommender.add_prerequisite_relationship("calculus", "algebra")
    recommender.add_prerequisite_relationship("calculus", "trigonometry")
    recommender.add_prerequisite_relationship("algebra", "basic_math")
    recommender.add_prerequisite_relationship("trigonometry", "geometry")
    recommender.add_prerequisite_relationship("geometry", "basic_math")
    recommender.add_prerequisite_relationship("linear_algebra", "algebra")
    recommender.add_prerequisite_relationship("differential_equations", "calculus")
    recommender.add_prerequisite_relationship("differential_equations", "linear_algebra")
    recommender.add_prerequisite_relationship("statistics", "algebra")
    recommender.add_prerequisite_relationship("probability", "basic_math")
    recommender.add_prerequisite_relationship("statistics", "probability")

    # Sample interaction log
    interactions = [
        ("student1", "basic_math", True),
        ("student1", "geometry", True),
        ("student1", "algebra", False),
        ("student2", "basic_math", True),
        ("student2", "algebra", True),
        ("student2", "trigonometry", True),
        ("student3", "basic_math", True),
        ("student3", "algebra", True),
        ("student3", "geometry", True),
        ("student3", "trigonometry", True),
        ("student3", "calculus", True),
    ]

    # Load interactions
    recommender.load_interaction_log(interactions)

    # Test recommendations
    print("=== Personalized Learning Path Recommendations ===\n")

    # Test case 1: Student 1 wants to learn calculus
    print("Student 1 - Target: Calculus")
    result = recommender.recommend_prerequisites("student1", "calculus")
    print(f"Mastered concepts: {recommender.student_progress['student1'].mastered_concepts}")
    print(f"Required prerequisites: {result['prerequisites']}")
    print(f"Recommended learning path: {result['learning_path']}")
    print(f"Number of concepts to learn: {result['num_prerequisites']}\n")

    # Test case 2: Student 2 wants to learn differential equations
    print("Student 2 - Target: Differential Equations")
    result = recommender.recommend_prerequisites("student2", "differential_equations")
    print(f"Mastered concepts: {recommender.student_progress['student2'].mastered_concepts}")
    print(f"Required prerequisites: {result['prerequisites']}")
    print(f"Recommended learning path: {result['learning_path']}")
    print(f"Number of concepts to learn: {result['num_prerequisites']}\n")

    # Test case 3: Student 3 wants to learn statistics
    print("Student 3 - Target: Statistics")
    result = recommender.recommend_prerequisites("student3", "statistics")
    print(f"Mastered concepts: {recommender.student_progress['student3'].mastered_concepts}")
    print(f"Required prerequisites: {result['prerequisites']}")
    print(f"Recommended learning path: {result['learning_path']}")
    print(f"Number of concepts to learn: {result['num_prerequisites']}\n")

    # Show top concepts by PageRank for Student 1 targeting calculus
    print("Top 5 concepts by PageRank relevance (Student 1 -> Calculus):")
    result = recommender.recommend_prerequisites("student1", "calculus")
    top_concepts = sorted(
        result['pagerank_scores'].items(),
        key=lambda x: x[1],
        reverse=True
    )[:5]
    for concept, score in top_concepts:
        print(f"  {concept}: {score:.4f}")


if __name__ == "__main__":
    main()